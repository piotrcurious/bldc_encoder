/*
 * Arduino Uno HDD BLDC Motor as Rotary Encoder
 *
 * This sketch is a port of the ESP32 version and demonstrates how to
 * use a 3-phase brushless DC motor from an HDD as a rotary encoder
 * with an Arduino Uno.
 *
 * It utilizes the Arduino's Pin Change Interrupts (PCINT) to detect
 * the zero-crossings of the back-EMF generated by the spinning motor.
 *
 * Connections:
 * - Connect the three phases of the BLDC motor (A, B, and C) to Arduino
 * pins 8, 9, and 10. These pins are on the same port (PORTB) which allows
 * us to use a single Pin Change Interrupt vector.
 * - A virtual ground setup (as described in the ESP32 version) is
 * recommended but this code relies on the digital states and internal
 * pull-ups which can often work directly.
 *
 * How it works:
 * 1.  This version uses Pin Change Interrupts. We configure pins 8, 9, and 10
 * (PCINT0, PCINT1, PCINT2) to trigger a single interrupt service
 * routine (ISR) named ISR(PCINT0_vect) whenever any of them change state.
 * 2.  Inside the ISR, we read the state of all three pins to get a 3-bit code
 * representing the motor's current angular sector.
 * 3.  A look-up table (LUT) is used to compare the current state with the
 * previous state to determine the direction of rotation (+1 or -1).
 * 4.  The global 'position' variable is updated accordingly.
 */

// Define the GPIO pins connected to the three motor phases.
// These must be on the same port for Pin Change Interrupts.
// Pins 8, 9, 10 are PB0, PB1, PB2 on the ATmega328P.
#define PHASE_A_PIN 8
#define PHASE_B_PIN 9
#define PHASE_C_PIN 10

// Volatile variables to be safely accessed by both the ISR and the main loop
volatile int32_t position = 0;
volatile int8_t last_state = 0;

// Pin Change Interrupt Service Routine for PCINT0 vector (covers pins 8-13)
ISR(PCINT0_vect) {
  // Read the current state of the three phases
  bool a = digitalRead(PHASE_A_PIN);
  bool b = digitalRead(PHASE_B_PIN);
  bool c = digitalRead(PHASE_C_PIN);

  // Combine the phase states into a single 3-bit integer (0-7)
  int8_t current_state = (c << 2) | (b << 1) | a; // Note: Remapped for clarity if needed, but direct is fine. Let's keep it consistent:
  // int8_t current_state = (a_val << 2) | (b_val << 1) | c_val;
  // Let's stick to the original state mapping which is known to work with the LUT.
  // The important thing is that the mapping is consistent between reading and the LUT.
  // Let's use the physical pin mapping to state bits for simplicity.
  // Pin 8 (A) -> bit 0, Pin 9 (B) -> bit 1, Pin 10 (C) -> bit 2
   current_state = (digitalRead(PHASE_C_PIN) << 2) | (digitalRead(PHASE_B_PIN) << 1) | digitalRead(PHASE_A_PIN);


  // If the state has changed since the last interrupt
  if (current_state != last_state) {
    // This look-up table (LUT) translates state transitions to position changes.
    // The index is calculated from the previous and current state.
    // The state sequence for one direction is 5 -> 4 -> 6 -> 2 -> 3 -> 1
    const int8_t lut[8][8] = {
      // Current state:
      //0, 1, 2, 3, 4, 5, 6, 7  // Previous state
        {0, 1,-1, 0,-1, 0, 0, 0}, // 0
        {-1,0, 0, 0, 0, 1, 0, 0}, // 1
        { 1,0, 0, 0, 0, 0,-1, 0}, // 2
        { 0,0, 0, 0, 1,-1, 0, 0}, // 3
        { 1,0, 0,-1, 0, 0, 0, 0}, // 4
        { 0,-1,0, 1, 0, 0, 0, 0}, // 5
        { 0,0, 1, 0, 0, 0, 0,-1}, // 6
        { 0,0, 0, 0, 0, 0, 1, 0}  // 7
    };
    // Note: This LUT might need to be adjusted based on the specific motor wiring.
    // The one from the previous example is a common one. Let's use a known robust one.
    const int8_t robust_lut[8][8] = {
        // new: 0  1  2  3  4  5  6  7       // old
        {0, -1, 1, 0, 1, 0, -1, 0},      // 0
        {1, 0, -1, 0, 0, -1, 0, 0},      // 1
        {-1, 1, 0, 0, -1, 0, 1, 0},      // 2
        {0, 0, 0, 0, 0, 1, -1, 0},      // 3
        {-1, 0, 1, 0, 0, 0, 0, 1},      // 4
        {0, 1, 0, -1, 0, 0, 1, 0},      // 5
        {1, 0, -1, 1, 0, -1, 0, 0},      // 6
        {0, 0, 0, 0, -1, 0, 1, 0},      // 7
    };

    position += robust_lut[last_state][current_state];
    last_state = current_state;
  }
}

void setup() {
  // Start serial communication for debugging
  Serial.begin(115200);
  Serial.println("Arduino Uno BLDC Motor Encoder Example");

  // Configure the phase pins as inputs with internal pull-up resistors.
  pinMode(PHASE_A_PIN, INPUT_PULLUP);
  pinMode(PHASE_B_PIN, INPUT_PULLUP);
  pinMode(PHASE_C_PIN, INPUT_PULLUP);

  // --- Pin Change Interrupt Setup ---
  cli(); // Disable interrupts globally

  // Enable Pin Change Interrupts for the port our pins are on (PORTB -> PCIE0)
  PCICR |= (1 << PCIE0);

  // Enable Pin Change Interrupts for the specific pins we are using
  // Pin 8 is PCINT0, Pin 9 is PCINT1, Pin 10 is PCINT2
  PCMSK0 |= (1 << PCINT0) | (1 << PCINT1) | (1 << PCINT2);

  sei(); // Enable interrupts globally

  // Initialize the last_state variable with the initial state of the pins
  last_state = (digitalRead(PHASE_C_PIN) << 2) | (digitalRead(PHASE_B_PIN) << 1) | digitalRead(PHASE_A_PIN);
}

void loop() {
  int32_t current_position;

  // Temporarily disable interrupts to safely read the volatile position variable.
  // On an 8-bit MCU like the Uno, reading a 32-bit variable is not atomic.
  cli(); // Disable interrupts
  current_position = position;
  sei(); // Enable interrupts

  // Print the current position to the Serial Monitor
  Serial.print("Position: ");
  Serial.println(current_position);

  // Add a small delay to avoid flooding the Serial Monitor
  delay(100);
}
