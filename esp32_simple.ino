/*
 * ESP32 HDD BLDC Motor as Rotary Encoder
 *
 * This sketch demonstrates how to use a 3-phase brushless DC motor,
 * typically found in hard disk drives (HDDs), as a rotary encoder
 * using an ESP32 microcontroller.
 *
 * It utilizes the ESP32's analog comparators and interrupts to detect
 * the zero-crossings of the back-EMF generated by the spinning motor.
 *
 * Connections:
 * - Connect the three phases of the BLDC motor (let's call them A, B, and C)
 * to three analog-capable GPIO pins on the ESP32.
 * - Create a virtual ground by connecting three resistors (e.g., 10k Ohm)
 * in a Y-configuration to the motor phases. The center point of the Y
 * will be our virtual ground.
 * - Connect this virtual ground to another analog-capable GPIO pin.
 *
 * How it works:
 * 1.  When the BLDC motor is spun manually, its coils generate a back-EMF
 * (electromotive force), which is a sinusoidal voltage.
 * 2.  We use the ESP32's analog comparators to detect when the voltage of
 * each phase crosses the voltage of the virtual ground (zero-crossing).
 * 3.  Each zero-crossing event triggers an interrupt.
 * 4.  By keeping track of the sequence of these interrupts from the three
 * phases, we can determine the direction and position of the motor's rotation.
 * 5.  The state of the three phases can be represented by a 3-bit number.
 * The sequence of these states for one direction of rotation is
 * typically 5, 4, 6, 2, 3, 1 and the reverse for the opposite direction.
 */

// Define the GPIO pins connected to the three motor phases
#define PHASE_A_PIN 32
#define PHASE_B_PIN 33
#define PHASE_C_PIN 35

// Volatile variables to be safely accessed by both the ISR and the main loop
volatile int32_t position = 0;
volatile int8_t last_state = 0;

// Interrupt Service Routine (ISR) that will be called on any pin change
void IRAM_ATTR isr() {
  // Read the current state of the three phases
  // digitalRead is fast enough for this purpose
  bool a = digitalRead(PHASE_A_PIN);
  bool b = digitalRead(PHASE_B_PIN);
  bool c = digitalRead(PHASE_C_PIN);

  // Combine the phase states into a single 3-bit integer (0-7)
  int8_t current_state = (a << 2) | (b << 1) | c;

  // If the state has changed since the last interrupt
  if (current_state != last_state) {
    // This look-up table (LUT) translates state transitions to position changes.
    // The index is calculated from the previous and current state.
    // A value of 1 means clockwise, -1 means counter-clockwise, 0 means invalid transition.
    // The sequence for one direction is 5 -> 4 -> 6 -> 2 -> 3 -> 1
    // And the reverse for the other direction.
    // e.g., transition from state 5 (101) to 4 (100) is one step.
    const int8_t lut[8][8] = {
      // Current state:
      //0, 1, 2, 3, 4, 5, 6, 7  // Previous state
        {0, 0, 0, 0, 0, 0, 0, 0}, // 0
        {0, 0, 0, 1, 0,-1, 0, 0}, // 1
        {0, 0, 0, 0, 1, 0,-1, 0}, // 2
        {0,-1, 0, 0, 0, 0, 0, 1}, // 3
        {0, 0,-1, 0, 0, 1, 0, 0}, // 4
        {0, 1,-0,-0,-1, 0, 0, 0}, // 5
        {0, 0, 1,-0, 0, 0, 0,-1}, // 6
        {0, 0, 0, 0, 0, 0, 0, 0}  // 7
    };
    
    // Get the change in position from the LUT
    int8_t pos_change = lut[last_state][current_state];
    
    // Update the global position variable
    position += pos_change;

    // Store the current state for the next interrupt
    last_state = current_state;
  }
}

void setup() {
  // Start serial communication for debugging
  Serial.begin(115200);
  Serial.println("ESP32 BLDC Motor Encoder Example");

  // Configure the phase pins as inputs with internal pull-up resistors.
  // Pull-ups help to define the state when the back-EMF is near zero.
  pinMode(PHASE_A_PIN, INPUT_PULLUP);
  pinMode(PHASE_B_PIN, INPUT_PULLUP);
  pinMode(PHASE_C_PIN, INPUT_PULLUP);

  // Attach the interrupt to all three phase pins.
  // The ISR will be called whenever the pin value changes (RISING or FALLING edge).
  attachInterrupt(digitalPinToInterrupt(PHASE_A_PIN), isr, CHANGE);
  attachInterrupt(digitalPinToInterrupt(PHASE_B_PIN), isr, CHANGE);
  attachInterrupt(digitalPinToInterrupt(PHASE_C_PIN), isr, CHANGE);

  // Initialize the last_state variable with the initial state of the pins
  bool a = digitalRead(PHASE_A_PIN);
  bool b = digitalRead(PHASE_B_PIN);
  bool c = digitalRead(PHASE_C_PIN);
  last_state = (a << 2) | (b << 1) | c;
}

void loop() {
  // Create a temporary variable to hold the position value
  // This is good practice to avoid issues with volatile variables
  // that might be updated by the ISR at any time.
  int32_t current_position;

  // Temporarily disable interrupts to safely read the volatile position variable
  noInterrupts();
  current_position = position;
  interrupts();

  // Print the current position to the Serial Monitor
  Serial.print("Position: ");
  Serial.println(current_position);

  // Add a small delay to avoid flooding the Serial Monitor
  delay(100);
}
